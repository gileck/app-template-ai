---
description: when managing state in the application (client state, server state, offline support)
globs: 
alwaysApply: false
---
# State Management Guidelines

This application uses a modern state management architecture optimized for PWA with offline support:

- **Zustand**: Client state (persisted to localStorage)
- **React Query**: Server state (persisted to IndexedDB)
- **Offline-first**: All mutations handle offline mode gracefully

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                     React Components                         │
├─────────────────────────────────────────────────────────────┤
│  Zustand Stores           │  React Query Hooks              │
│  (Client State)           │  (Server State)                 │
│  - features/auth/store    │  - useQuery                     │
│  - features/settings/store│  - useMutation                  │
│  - features/router/store  │  - useQueryClient               │
├─────────────────────────────────────────────────────────────┤
│  localStorage             │  IndexedDB                      │
│  (Zustand persist)        │  (React Query persist)          │
└─────────────────────────────────────────────────────────────┘
```

## When to Use What

| State Type | Solution | Persistence | Example |
|------------|----------|-------------|---------|
| User preferences | Zustand | localStorage | Theme, offline mode |
| Auth hints | Zustand | localStorage | `isProbablyLoggedIn`, `userPublicHint` |
| Persistent UI state | Zustand | localStorage | Last route, saved filters |
| Server data | React Query | IndexedDB | Todos, user profile |
| Ephemeral UI state | useState | None | Modal open, form inputs, loading |

### ✅ When to Use `useState` (Ephemeral State)

Use `useState` for state that should NOT survive app restart - this is native-like behavior:

```typescript
// ✅ CORRECT: Ephemeral UI state
const [isModalOpen, setIsModalOpen] = useState(false);
const [inputValue, setInputValue] = useState('');
const [isSubmitting, setIsSubmitting] = useState(false);
const [expandedAccordion, setExpandedAccordion] = useState<string | null>(null);
```

### ❌ When NOT to Use `useState`

```typescript
// ❌ WRONG: Server data should use React Query
const [todos, setTodos] = useState<Todo[]>([]);
useEffect(() => { fetchTodos().then(setTodos); }, []);

// ❌ WRONG: User preferences should use Zustand
const [theme, setTheme] = useState('light');

// ❌ WRONG: Data fetching state should use React Query
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
```

### Decision Flowchart

```
Does this state come from an API?
  YES → Use React Query
  NO ↓

Should this state persist across app restarts?
  YES → Use Zustand store
  NO ↓

Is this temporary UI state (modal, form input, hover)?
  YES → Use useState ✅
```

## Zustand Stores

### Philosophy: Many Small Stores ✅

Zustand recommends **separate, focused stores** over a single large store:

| Aspect | Single Store ❌ | Separate Stores ✅ |
|--------|----------------|-------------------|
| Re-renders | Any change triggers all selectors | Only affected components re-render |
| Persistence | One TTL for everything | Independent TTLs per feature |
| Feature isolation | All features coupled | Each feature owns its state |
| Testing | Hard to test slices | Easy to test in isolation |
| Adding features | Modify central file | Create new `features/x/store.ts` |

### Store Structure

Each feature has its own store in `features/{name}/store.ts`:

```
src/client/features/
├── auth/store.ts       # Auth state + instant-boot hints
├── settings/store.ts   # User preferences + offline mode
└── router/store.ts     # Route persistence for PWA
```

### Imports

```typescript
// Import from feature folders
import { useAuthStore, useUser, useIsProbablyLoggedIn } from '@/client/features/auth';
import { useSettingsStore, useEffectiveOffline } from '@/client/features/settings';
import { useRouteStore } from '@/client/features/router';

// Or import all from features index
import { useAuthStore, useSettingsStore, useRouteStore } from '@/client/features';
```

### Settings Store
```typescript
import { useSettingsStore, useEffectiveOffline } from '@/client/features/settings';

// Read settings
const theme = useSettingsStore((state) => state.settings.theme);
const offlineMode = useSettingsStore((state) => state.settings.offlineMode);

// Update settings
const updateSettings = useSettingsStore((state) => state.updateSettings);
updateSettings({ theme: 'dark' });

// Check effective offline status (user toggle OR device offline)
const effectiveOffline = useEffectiveOffline();
```

### Auth Store
```typescript
import { useAuthStore, useUser, useIsProbablyLoggedIn } from '@/client/features/auth';

// Read auth state
const user = useUser(); // Validated user data
const isProbablyLoggedIn = useIsProbablyLoggedIn(); // Persisted hint
const isValidated = useAuthStore((state) => state.isValidated);

// Update auth (typically done in mutation hooks)
const setValidatedUser = useAuthStore((state) => state.setValidatedUser);
const clearAuth = useAuthStore((state) => state.clearAuth);
```

### Route Store
```typescript
import { useRouteStore } from '@/client/features/router';

// Route persistence (handled automatically by router)
const lastRoute = useRouteStore((state) => state.lastRoute);
const setLastRoute = useRouteStore((state) => state.setLastRoute);
```

### Creating a New Store

When adding a new feature that needs client state:

1. Create `src/client/features/{name}/store.ts`
2. Create `src/client/features/{name}/index.ts` to export it
3. Add export to `src/client/features/index.ts`
4. **Use centralized defaults from `@/client/config`**

```typescript
// features/notifications/store.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { STORE_DEFAULTS, createTTLValidator } from '@/client/config';

// Use centralized TTL (or override with custom value)
const isValid = createTTLValidator(STORE_DEFAULTS.TTL); // Default: 7 days

interface NotificationState {
    unreadCount: number;
    lastCheckedAt: number | null;
    setUnreadCount: (count: number) => void;
}

export const useNotificationStore = create<NotificationState>()(
    persist(
        (set) => ({
            unreadCount: 0,
            lastCheckedAt: null,
            setUnreadCount: (count) => set({ 
                unreadCount: count, 
                lastCheckedAt: Date.now() 
            }),
        }),
        {
            name: 'notification-storage',
            onRehydrateStorage: () => (state) => {
                // Expire old state using centralized TTL
                if (state && !isValid(state.lastCheckedAt)) {
                    state.unreadCount = 0;
                    state.lastCheckedAt = null;
                }
            },
        }
    )
);
```

## Centralized Configuration

**All defaults live in ONE place**: `src/client/config/defaults.ts`

```typescript
import { TIME, STORE_DEFAULTS, QUERY_DEFAULTS, createTTLValidator } from '@/client/config';

// Time constants
TIME.SECOND  // 1000
TIME.MINUTE  // 60 * 1000
TIME.HOUR    // 60 * 60 * 1000
TIME.DAY     // 24 * 60 * 60 * 1000

// Zustand store TTLs
STORE_DEFAULTS.TTL           // 7 days (default)
STORE_DEFAULTS.TTL_SHORT     // 1 day
STORE_DEFAULTS.TTL_LONG      // 30 days
STORE_DEFAULTS.TTL_AUTH_HINT // 7 days
STORE_DEFAULTS.TTL_ROUTE     // 30 days

// React Query cache times
QUERY_DEFAULTS.STALE_TIME    // 30 seconds
QUERY_DEFAULTS.GC_TIME       // 30 minutes
QUERY_DEFAULTS.MAX_STALE_AGE // 24 hours

// TTL validator helper
const isValid = createTTLValidator(STORE_DEFAULTS.TTL);
if (!isValid(timestamp)) { /* expired */ }
```

### Override When Needed

```typescript
// Use default TTL (7 days)
const isValid = createTTLValidator(STORE_DEFAULTS.TTL);

// Override with custom TTL
const isValid = createTTLValidator(2 * TIME.HOUR); // 2 hours
```

## React Query Patterns

### Centralized Cache Config

Hooks use `useQueryDefaults()` which reads from centralized config:

```typescript
// src/client/query/defaults.ts
import { QUERY_DEFAULTS } from '@/client/config';

export function useQueryDefaults() {
    const swr = useSettingsStore((s) => s.settings.staleWhileRevalidate);
    return {
        staleTime: swr ? QUERY_DEFAULTS.STALE_TIME : 0,
        gcTime: QUERY_DEFAULTS.GC_TIME,
    };
}
```

### Query Hook Pattern

Hooks are SIMPLE - no cache config needed:

```typescript
// src/client/routes/[ROUTE]/hooks.ts
import { useQuery } from '@tanstack/react-query';
import { useQueryDefaults } from '@/client/query';

export const todosQueryKey = ['todos'] as const;

export function useTodos() {
    const queryDefaults = useQueryDefaults(); // Gets config from settings
    
    return useQuery({
        queryKey: todosQueryKey,
        queryFn: async () => {
            const response = await getTodos({});
            if (response.data?.error) throw new Error(response.data.error);
            return response.data;
        },
        ...queryDefaults, // Spread defaults - no hardcoded values!
    });
}
```

### Mutation Hook Pattern with Optimistic Updates

```typescript
export function useUpdateTodo() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (data: UpdateTodoRequest) => {
            const response = await updateTodo(data);
            if (response.data?.error) throw new Error(response.data.error);
            return response.data?.todo;
        },
        
        onMutate: async (variables) => {
            await queryClient.cancelQueries({ queryKey: todosQueryKey });
            const previous = queryClient.getQueryData(todosQueryKey);
            
            // Optimistic update
            queryClient.setQueryData(todosQueryKey, (old) => ({
                todos: old.todos.map(t => 
                    t._id === variables.todoId ? { ...t, ...variables } : t
                ),
            }));
            
            return { previous };
        },
        
        onError: (_err, _vars, context) => {
            if (context?.previous) {
                queryClient.setQueryData(todosQueryKey, context.previous);
            }
        },
        
        // ⚠️ CRITICAL: Handle empty data from offline mode
        onSuccess: (data) => {
            if (data && data._id) {
                queryClient.setQueryData(['todos', data._id], { todo: data });
            }
            queryClient.invalidateQueries({ queryKey: todosQueryKey });
        },
    });
}
```

## ⚠️ Offline Mode - CRITICAL

### How Offline Mode Works

1. When offline, `apiClient.post` queues the request and returns `{ data: {}, isFromCache: false }`
2. Optimistic updates show changes immediately in the UI
3. When online, queued requests sync via `/api/process/batch-updates`
4. After sync, React Query caches are invalidated to fetch fresh data

### Mutation Callbacks MUST Handle Empty Data

```typescript
// ✅ CORRECT: Guard against empty data
onSuccess: (data) => {
    if (data && data.todo) {
        queryClient.setQueryData(['todos', data.todo._id], { todo: data.todo });
    }
    queryClient.invalidateQueries({ queryKey: ['todos'] });
},

// ❌ WRONG: Will crash when offline (data is {})
onSuccess: (data) => {
    queryClient.setQueryData(['todos', data.todo._id], data); // CRASH!
},
```

### Testing Offline Mode

1. Go to Settings → Enable "Offline Mode"
2. Perform mutations (create, update, delete)
3. UI should update optimistically (no errors)
4. Disable offline mode
5. Queued requests should sync automatically

## PWA Instant Boot

The architecture enables instant app startup after iOS kills the app:

1. **Auth Hint**: `isProbablyLoggedIn` loads from localStorage instantly
2. **UI Shell**: App renders immediately with cached user hint
3. **Route Restore**: Last visited route is restored from `useRouteStore`
4. **Data Cache**: React Query loads cached data from IndexedDB
5. **Background Validation**: Auth and data revalidate in background

## Key Files

| File | Purpose |
|------|---------|
| `src/client/config/defaults.ts` | **Centralized TTL/cache defaults** |
| `src/client/features/settings/store.ts` | Settings with offline mode |
| `src/client/features/auth/store.ts` | Auth with instant-boot hints |
| `src/client/features/auth/hooks.ts` | Auth mutations (login, logout) |
| `src/client/features/router/store.ts` | Route persistence for PWA |
| `src/client/query/QueryProvider.tsx` | React Query + IndexedDB persistence |
| `src/client/query/defaults.ts` | React Query defaults (uses config) |
| `src/client/utils/apiClient.ts` | API client with offline queue |
| `src/client/utils/offlinePostQueue.ts` | POST request queue + batch sync |

## Import Patterns

```typescript
// ✅ Import from feature folders (preferred)
import { useAuthStore, useUser, useLogin } from '@/client/features/auth';
import { useSettingsStore } from '@/client/features/settings';
import { useRouteStore } from '@/client/features/router';

// ✅ Import from features index (convenience)
import { useAuthStore, useSettingsStore } from '@/client/features';

// ⚠️ Legacy re-export (backwards compatible, but prefer features/)
import { useAuthStore } from '@/client/stores';
```
